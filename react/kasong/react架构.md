在上一节中，我们了解了 React 的理念，即实现快速响应的用户体验。然而，React 从 v15 升级到 v16，重写了整个架构，这是因为 v15 的架构无法满足快速响应的理念。本节我们深入探讨 React15 的架构及其缺陷，了解为什么需要对其进行重构。

### React15 架构概览

React15 的架构主要分为两层：

1. **Reconciler（协调器）**：负责找出组件的变化部分。
2. **Renderer（渲染器）**：负责将变化的组件渲染到特定的平台环境中。

#### Reconciler（协调器）

在 React 中，每当调用 `this.setState`、`this.forceUpdate` 或 `ReactDOM.render` 等 API 时，都会触发更新。Reconciler 的主要工作流程如下：

- **组件渲染**：调用函数组件或类组件的 `render` 方法，将返回的 JSX 转换为虚拟 DOM。
- **差异比较**：将新的虚拟 DOM 与上一次更新时的虚拟 DOM 进行比较。
- **找出变化**：通过对比，找出本次更新中发生变化的部分。
- **通知 Renderer**：将变化的部分通知给 Renderer，以便进行渲染。

#### Renderer（渲染器）

Renderer 根据不同的平台环境，将变化的组件渲染到相应的宿主环境中。例如：

- **ReactDOM**：浏览器环境中的渲染器。
- **React Native Renderer**：用于渲染原生移动应用组件。
- **React Test Renderer**：用于测试，渲染出纯 JavaScript 对象。

### React15 架构的缺陷

#### 同步递归更新的问题

在 React15 中，组件的挂载（mount）和更新（update）都是通过递归的方式进行的。当调用 `mountComponent` 或 `updateComponent` 时，都会递归地处理子组件。这种同步递归更新存在以下问题：

- **无法中断**：一旦更新开始，就无法在中途中断。
- **阻塞主线程**：当组件层级很深或数量庞大时，递归更新可能会占用较长的时间，超过了浏览器一帧的时间（约 16ms）。
- **导致卡顿**：由于 JavaScript 执行会阻塞页面渲染，长时间的递归更新会导致用户交互卡顿，影响用户体验。

#### 无法支持异步可中断的更新

为了实现快速响应，需要将同步的更新转换为**可中断的异步更新**。这意味着在更新过程中，可以暂停当前的任务，让浏览器有时间渲染页面，从而保持界面的流畅性。然而，React15 的架构无法支持这种机制。

#### 更新中断导致的不一致性

通过一个简单的乘法示例，我们模拟了在更新过程中中断的情况。在同步更新的流程中，Reconciler 和 Renderer 交替工作，整个过程是同步的，用户看到的 DOM 更新是同时发生的。

如果我们在更新第一个 `li` 后中断更新（注意，React15 实际上并不会中断更新，这是一个模拟），那么第二个 `li` 并没有更新。结果，用户将看到一个不完整或不一致的界面（例如，本应显示 `2 4 6`，却看到 `2 2 3`）。这种不一致性是无法接受的。

### 重构的必要性

由于上述原因，React 需要重写其架构，以支持可中断的异步更新。这样可以：

- **提高响应性**：在长时间的更新过程中，可以中断任务，优先处理用户交互等高优先级的事件。
- **避免卡顿**：通过将长任务拆分为多个小任务，利用空闲时间执行，减少对主线程的阻塞。
- **保持界面一致性**：新的架构下，即使更新被中断，也能确保界面不会出现不一致的状态。

### 总结

React15 的架构由于采用同步递归更新的方式，无法满足快速响应的理念。主要问题在于：

- **更新过程不可中断**：导致长时间阻塞主线程，影响用户体验。
- **无法支持异步更新**：限制了性能优化的空间。

为了解决这些问题，React 从 v16 开始，重写了架构，引入了 Fiber 架构，支持可中断的异步更新。这使得 React 能够更好地利用浏览器的渲染机制，提高应用的性能和响应速度。

React 的重构体现了其对用户体验的重视和对性能优化的追求。通过深入理解 React15 的缺陷，我们更能欣赏 React16 所带来的革新。
